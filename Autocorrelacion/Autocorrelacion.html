<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Autocorrelación</title>
    <meta charset="utf-8" />
    <meta name="author" content="Gustavo A. García   ggarci24@eafit.edu.co                  " />
    <script src="libs/header-attrs-2.25/header-attrs.js"></script>
    <script src="libs/clipboard-2.0.6/clipboard.min.js"></script>
    <link href="libs/xaringanExtra-clipboard-0.2.6/xaringanExtra-clipboard.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-clipboard-0.2.6/xaringanExtra-clipboard.js"></script>
    <script>window.xaringanExtraClipboard(null, {"button":"<i class=\"fa fa-clipboard\"><\/i>","success":"<i class=\"fa fa-check\" style=\"color: #90BE6D\"><\/i>","error":"<i class=\"fa fa-times-circle\" style=\"color: #F94144\"><\/i>"})</script>
    <link href="libs/font-awesome-6.4.2/css/all.min.css" rel="stylesheet" />
    <link href="libs/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet" />
    <link href="libs/xaringanExtra-extra-styles-0.2.6/xaringanExtra-extra-styles.css" rel="stylesheet" />
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Autocorrelación
]
.author[
### Gustavo A. García <br> <span class="notbold" style="font-size:65%"><a href="mailto:ggarci24@eafit.edu.co" class="email">ggarci24@eafit.edu.co</a></span> <br> <br> <br> <br> <br> <br> <br> <br> <br>
]
.date[
### <span class="notbold" style="font-size:65%">Econometría II <br> Programa de Economía <br> Universidad EAFIT</span>
]

---




&lt;style&gt;
.notbold{
    font-weight:normal
}

body {
text-align: justify;
}

h1{
      margin-top: -1px;
      margin-bottom: -3px;
}

.small-code pre{
  margin-bottom: -10px;
  
}  

.medium-code pre{
  margin-bottom: 2px;
  
} 
&lt;/style&gt;






&lt;font size = "5"&gt;

&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;

Link slides en formato [html](https://gusgarciacruz.github.io/EconometriaII/Autocorrelacion/Autocorrelacion.html)

Link slides en formato [PDF](https://gusgarciacruz.github.io/EconometriaII/Autocorrelacion/Autocorrelacion.pdf)
---
# &lt;span style="font-size:80%"&gt;En este tema&lt;/span&gt;

- &lt;span style="font-size:150%"&gt;[&lt;span style="color:black"&gt;Naturaleza del problema](#naturaleza)&lt;/span&gt; &lt;br&gt; &lt;br&gt;

- &lt;span style="font-size:150%"&gt; [&lt;span style="color:black"&gt;Consecuencias de utilizar MCO en presencia de autocorrelación](#consecuencias)&lt;/span&gt; &lt;br&gt; &lt;br&gt;

- &lt;span style="font-size:150%"&gt; [&lt;span style="color:black"&gt;Estructuras de la autocorrelación](#estructuras)&lt;/span&gt; &lt;br&gt; &lt;br&gt;

- &lt;span style="font-size:150%"&gt; [&lt;span style="color:black"&gt;Detección de la autocorrelación](#deteccion)&lt;/span&gt; &lt;br&gt; &lt;br&gt;

- &lt;span style="font-size:150%"&gt; [&lt;span style="color:black"&gt;Solución a la autocorrelación: el estimador MCG](#solucion)&lt;/span&gt; &lt;br&gt; &lt;br&gt;

- &lt;span style="font-size:150%"&gt; [&lt;span style="color:black"&gt;Ejercicio aplicado en R: relación entre salarios y productividad](#r)&lt;/span&gt;

---
# &lt;span style="font-size:80%"&gt;Lecturas&lt;/span&gt;
- &lt;span style="font-size:150%"&gt;Wooldridge, J. (2013). *Introducción a la econometría*. 5a edición, Cengage Learning. &lt;span style="color:blue"&gt;Caps 10, 11 y 12 &lt;br&gt; &lt;br&gt;

- &lt;span style="font-size:150%"&gt; Gujarati, D. y Porter, D. (2010). *Econometría*. 5a edición, Mc Graw Hill. &lt;span style="color:blue"&gt;Cap 12 &lt;br&gt; &lt;br&gt;

---
name: naturaleza
# &lt;span style="font-size:80%"&gt;Naturaleza del problema&lt;/span&gt;

- En estudios con datos de corte transversal es más común la presencia de heteroscedasticidad 

- Ya que los datos de corte transversal se recopilan con base en una muestra aleatoria de unidades transversales (familias o empresas) no existe razón previa para pensar que el término de error correspondiente a una familia o empresa esté correlacionado con el término de error de otra familia o empresa `\(\Longrightarrow\)` a menos de que exista &lt;font color = "blue"&gt;autocorrelación espacial&lt;/font&gt;, es decir una autocorrelación en el espacio más que en el tiempo

- Cuando se trabajan con datos de series de tiempo, estos datos siguen un ordenamiento natural respecto del tiempo, &lt;font color = "blue"&gt;de modo que es muy posible que las observaciones sucesivas muestren intercorrelaciones, sobre todo si el intervalo ente observaciones sucesivas es muy corto, como un día, una semana o un mes: por ejemplo, los índices bursátiles como el Dow Jones o el S&amp;P500&lt;/font&gt;

- En esta situación de alta interrelación temporal entre los datos es más probable que se &lt;font color = "blue"&gt;viole el supuesto de no autocorrelación&lt;/font&gt;

---
# &lt;span style="font-size:80%"&gt;Naturaleza del problema&lt;/span&gt;

- &lt;font color = "blue"&gt;Autocorrelación&lt;/font&gt;: correlación entre miembros de series de observaciones ordenadas en el tiempo (datos de series de tiempo) o en el espacio (datos de corte transversal)

- En el contexto de regresión, el modelo clásico de regresión lineal supone que:

`$$Cov(u_{i},u_{j} | x_{i},x_{j})=E(u_{i}u_{j})=0 \text{ con } i\neq j$$`
- Pero en el contexto de series de tiempo principalmente es un supuesto que pueda no se mantenga lo que implica que `\(E(u_{i}u_{j})\neq 0\)`

---
# &lt;span style="font-size:80%"&gt;Naturaleza del problema&lt;/span&gt;

Visualicemos algunos patrones de autocorrelación y de no autocorrelación

&lt;img src="f1.png" width="38%" style="display: block; margin: auto;" /&gt;

---
# &lt;span style="font-size:80%"&gt;Naturaleza del problema&lt;/span&gt;

¿Por qué ocurre la correlación serial?
- &lt;font color = "blue"&gt;Inercia&lt;/font&gt; &lt;br&gt;
Las series de tiempo económicas se caracterizan por tener inercia o pasividad `\(\Longrightarrow\)` las observaciones sucesivas sean interdependientes


- &lt;font color = "blue"&gt;Sesgo de especificación&lt;/font&gt; &lt;br&gt;
&lt;p style="margin-bottom: -1em"&gt;
	- Variables excluidas
	- Forma funcional incorrecta

- &lt;font color = "blue"&gt;"Manipulación" o transformación de datos&lt;/font&gt;
&lt;p style="margin-bottom: -1em"&gt;	
	- Pasar de datos que son mensuales a trimestrales
	- Interpolación o extrapolación de datos

- &lt;font color = "blue"&gt;No estacionariedad&lt;/font&gt; &lt;br&gt;
Una serie de tiempo es &lt;font color = "blue"&gt;estacionaria&lt;/font&gt; si sus características (media, varianza y covarianza) son invariantes respecto al tiempo. Si no es así, tenemos una serie de tiempo &lt;font color = "blue"&gt;no estacionaria&lt;/font&gt;. Si en un modelo de regresión `\(Y\)` y las `\(X\)`s son no estacionarias, el término de error será no estacionario y por tanto mostrará autocorrelación 

---
name: consecuencias
# &lt;span style="font-size:80%"&gt;Consecuencias de utilizar MCO en presencia de autocorrelación&lt;/span&gt;

&lt;font color = "blue"&gt;¿Qué sucede con los estimadores MCO y sus varianzas si introducimos autocorrelación en las perturbaciones?&lt;/font&gt;

Partamos del siguiente modelo de RLS

`$$Y_{t} = \beta_{1} + \beta_{2}X_{t} + u_{t}$$`
Ahora debemos suponer el mecanismo que generan las `\(u_{t}\)`. Como punto de partida vamos a suponer sigue el siguiente proceso:

`$$u_{t}=\rho u_{t-1}+\epsilon_{t}$$`
donde `\(\rho\)` se conoce como &lt;font color = "blue"&gt;coeficiente de autocovarianza&lt;/font&gt; o &lt;font color = "blue"&gt;coeficiente de autocorrelación de primer orden&lt;/font&gt; y este esquema que sigue `\(u_{t}\)` se conoce como &lt;font color = "blue"&gt;esquema autorregresivo de primer orden&lt;/font&gt; y suele denotarse como &lt;font color = "blue"&gt;AR(1)&lt;/font&gt;

`\(\epsilon_{t}\)` es una perturbación aleatoria que satisface los supuestos estándar:

`$$E(\epsilon_{t})=0, \   \ Var(\epsilon_{t})=\sigma_{\epsilon}^{2}, \    \ Cov(\epsilon_{t},\epsilon_{t+s}) = 0 \   \ \text{ con } s\neq 0$$`
Con estas propiedades, `\(\epsilon_{t}\)` es lo que en la literatura le llaman un &lt;font color = "blue"&gt;término de error de ruido blanco&lt;/font&gt;

---
name: consecuencias
# &lt;span style="font-size:80%"&gt;Consecuencias de utilizar MCO en presencia de autocorrelación&lt;/span&gt;
&lt;font size = "3"&gt;
Es posible demostrar que con el esquema AR(1)

`$$Var(u_{t}) = \frac{\sigma_{\epsilon}^{2}}{1-\rho^2}$$`
`$$Cov(u_{t},u_{t+s})=E(u_{t}u_{t+s})=\rho^{s}\frac{\sigma_{\epsilon}^{2}}{1-\rho^2}$$`
`$$Cor(u_{t},u_{t+s})=\rho^{s}$$`

La matriz de varianzas-covarianzas de `\(u_{t}\)` tiene la forma

`$$Cov(\textbf{u}) = \frac{\sigma_{\epsilon}^2}{1-\rho^2} \left[ \begin{array}{ccccc}
1                 &amp; \rho             &amp; \rho^2           &amp; \ldots &amp; \rho^{T-1}  \\
\rho              &amp; 1                &amp; \rho             &amp; \ldots &amp; \rho^{T-2}  \\
\rho^2            &amp; \rho             &amp; 1                &amp; \ldots &amp; \rho^{T-3}  \\
\vdots            &amp; \vdots           &amp; \vdots           &amp; \vdots &amp; \vdots\\
\rho^{T-1}        &amp; \rho^{T-2}       &amp; \rho^{T-3}       &amp; \ldots &amp; 1  \\ 
\end{array} \right] = \sigma_{u}^2\boldsymbol\Omega \neq \sigma_{u}^2 \textbf{I}_{n}$$`

&lt;p style="margin-bottom: -1em"&gt;	
Note que bajo el esquema AR(1), `\(u_{t}\)` es:
- homocedástica
- autocorrelacionada

También note que resulta crítico que `\(|\rho|&lt;1\)`. Si por ejemplo `\(\rho=1\)` (raiz unitaria), las varianzas y covarianzas no están definidas. Si `\(|\rho|&lt;1\)`, se dice que el proceso AR(1) es estacionario, es decir la media, la varianza y la covarianza de `\(u_{t}\)` no cambian respecto al tiempo

---
# &lt;span style="font-size:80%"&gt;Consecuencias de utilizar MCO en presencia de autocorrelación&lt;/span&gt;

Volviendo al modelo de RLS, sabemos que el estimador MCO de la matriz var-cov de `\(\widehat{\textbf{B}}\)` es:

`$$Cov(\widehat{\textbf{B}}) = \sigma_{u}^2 (\textbf{X}'\textbf{X})^{-1}$$`

Ahora, con el esquema AR(1) la matriz var-cov de `\(\widehat{\textbf{B}}\)` será:
&lt;p style="margin-bottom: 2em"&gt;
`$$Cov(\widehat{\textbf{B}}) =\sigma_{u}^2(\textbf{X}'\textbf{X})^{-1}\textbf{X}'\Omega\textbf{X}(\textbf{X}'\textbf{X})^{-1}$$`

&lt;p style="margin-bottom: -1em"&gt;
En conclusión, si se aplica MCO a un modelo con autocorrelación:
- Los MCO continuan siendo insesgados y lineales
- Las varianzas y errores estándar de los estimadores son erróneos
- Los MCO no alcanzan la mínima varianza
- Se invalida la inferencia estadística: intervalos de confianza (más amplios) y pruebas de hipótesis (se tiende a no rechazar `\(H_0\)`)

---
name: estructuras
# &lt;span style="font-size:80%"&gt;Estructuras de la autocorrelación&lt;/span&gt;

&lt;font color = "blue"&gt;1. Proceso Autorregresivo lineal de primer orden  AR(1)&lt;/font&gt;

El proceso generador de datos AR(1) supone que:

`$$u_t = \rho u_{t-1} + \epsilon_t$$`
Con `\(\epsilon_t\)` siendo ruido blanco 

`$$E(\epsilon_t)=0$$`
`$$Var(\epsilon_t)=\sigma_{\epsilon}^2$$`
`$$Cov(\epsilon_t,\epsilon_s)=E(\epsilon_t\epsilon_s)=0 \   \ \forall t\neq s$$`
`$$Cov(\epsilon_t,u_{t-s})=E(\epsilon_{t}u_{t-s})=0 \   \ \forall t\neq s$$`

La matriz de var-cov para `\(u\)` puede representarse como:

`$$Cov(\textbf{u}) = \frac{\sigma_{\epsilon}^2}{1-\rho^2} \left[ \begin{array}{ccccc}
1                 &amp; \rho             &amp; \rho^2           &amp; \ldots &amp; \rho^{T-1}  \\
\rho              &amp; 1                &amp; \rho             &amp; \ldots &amp; \rho^{T-2}  \\
\rho^2            &amp; \rho             &amp; 1                &amp; \ldots &amp; \rho^{T-3}  \\
\vdots            &amp; \vdots           &amp; \vdots           &amp; \vdots &amp; \vdots\\
\rho^{T-1}        &amp; \rho^{T-2}       &amp; \rho^{T-3}       &amp; \ldots &amp; 1  \\ \end{array} \right] = \sigma_{u}^2\boldsymbol\Omega \neq \sigma_{u}^2 \textbf{I}_{n}$$`

El análisis puede extenderse a procesos autorregresivos de orden p, AR(p) 

---
# &lt;span style="font-size:80%"&gt;Estructuras de la autocorrelación&lt;/span&gt;

&lt;font color = "blue"&gt;1. Proceso Autorregresivo lineal de primer orden  AR(1)&lt;/font&gt;

En este mundo se ha desarrollado una notación eficiente para los rezagos con el operador `\(L\)`. Por ejemplo, el AR(1) se escribe como:

$$
`\begin{aligned}
u_t &amp; = \rho u_{t-1} + \epsilon_t\\
    &amp; = \rho L u_t + \epsilon_t\\
u_t - \rho L u_t &amp; = \epsilon_t\\
u_t &amp; = \frac{\epsilon_t}{1 - \rho L}
\end{aligned}`
$$
Así para un proceso AR(p) sería

$$
`\begin{aligned}
u_t &amp; = \rho_1 u_{t-1} + \rho_2 u_{t-2} + ... + \rho_p u_{t-p} + \epsilon_t\\
u_t &amp; = \rho_1 Lu_{t} + \rho_2 L^2 u_{t} + ... + \rho_p L^p u_{t} + \epsilon_t\\
u_t (1 - \rho_1 L + \rho_2 L^2 + ... + \rho_p L^p) &amp; = \epsilon_t\\
\end{aligned}`
$$
Se define el operador polinomio de rezagos como

`$$\rho(L) = 1 - \rho_1 L + \rho_2 L^2 + ... + \rho_p L^p$$`
El proceso AR(p) se expresa como

`$$\rho(L)u_t = \epsilon_t$$`

---
# &lt;span style="font-size:80%"&gt;Estructuras de la autocorrelación&lt;/span&gt;

&lt;font color = "blue"&gt;2. Proceso de Medias Moviles MA(1) de primer orden&lt;/font&gt;

Formalmente el proceso se expresa como:

`$$u_t = \theta \epsilon_{t-1} + \epsilon_t$$`

Con `\(\epsilon_t\)` siendo ruido blanco y `\(|\theta|&lt;1\)` condición de invertibilidad del proceso

La matriz de var-cov para `\(u\)` puede representarse como:

`$$Cov(\textbf{u}) = \sigma_{\epsilon}^2 (1+\theta^2) \left[ \begin{array}{cccc}
1                 &amp; \theta           &amp; \ldots &amp; 0  \\
\theta            &amp; 1                &amp; \ldots &amp; 0   \\
\vdots            &amp; \vdots           &amp; \vdots &amp; \vdots\\
0                 &amp; 0                &amp; \ldots &amp; 1  \\ \end{array} \right] = \sigma_{u}^2 \boldsymbol\Omega \neq \sigma_{u}^2 \textbf{I}_{n}$$`


El análisis puede extenderse a procesos de medias móviles de orden q, MA(q). 

En términos del operador de rezagos, el proceso MA(q) se expresa como 

$$
`\begin{aligned}
u_t &amp; = \epsilon_t + \theta_1 \epsilon_{t-1} + \theta_2 \epsilon_{t-2} + ... + \theta_q \epsilon_{t-q} \\
u_t &amp; = \epsilon_t + \theta_1 L\epsilon_{t} + \theta_2 L^2 \epsilon_{t} + ... + \theta_q L^q \epsilon_{t} + \epsilon_t\\
u_t &amp; = (1 - \theta_1 L + \theta_2 L^2 + ... + \theta_q L^q) \epsilon_t\\
u_t &amp; = \theta(L)\epsilon_t
\end{aligned}`
$$
 
---
# &lt;span style="font-size:80%"&gt;Estructuras de la autocorrelación&lt;/span&gt;
&lt;font color = "blue"&gt;3. Proceso ARMA(p,q)&lt;/font&gt;

Combina las generalizaciones de los dos anteriores procesos

`$$u_t = \rho_{1} u_{t-1} + ... + \rho_{p} u_{t-p} + \epsilon_t + \theta_{1} \epsilon_{t-1} + ... + \theta_{q} \epsilon_{t-q}$$`
`$$\rho(L)u_t = \theta(L)\epsilon_t$$`
---
name: deteccion
# &lt;span style="font-size:80%"&gt;Detección de la autocorrelación&lt;/span&gt;

&lt;font color = "blue"&gt;1. Método gráfico&lt;/font&gt;

- Recuerde que el supuesto de no autocorrelación del modelo clásico se relaciona con las perturbaciones poblacionales `\(u_t\)`, las cuales no pueden observarse directamente. En su lugar disponemos de valores sustitutos, los residuos `\(\widehat{u}_{t}\)`, a partir del procedimiento usual MCO

- Un examen visual de las `\(\widehat{u}\)` da algunas claves sobre la posible presencia de autocorrelación en las `\(u\)`

- En realidad, un examen visual de `\(\widehat{u}_t\)` o `\((\widehat{u}_{t}^2)\)` proporciona información útil no sólo sobre la autocorrelación, sino también sobre heteroscedasticidad, sobre el grado de adecuación del modelo o sobre el sesgo de especificación

- Hay diversas formas de examinar los residuales:
  - `\(\widehat{u}_t\)` contra el tiempo
	- los residuos estandarizados `\((\widehat{u}_t/\widehat{\sigma}_{u})\)` respecto del tiempo

---
# &lt;span style="font-size:80%"&gt;Detección de la autocorrelación&lt;/span&gt;


```r
library(gujarati); library(tidyverse) # install.packages("remotes"), remotes::install_github("brunoruas2/gujarati")

data("Table12_4") 
data &lt;- Table12_4 |&gt; mutate(year = as.numeric(as.character(Year)),
                            y = as.numeric(as.character(Y)), x = as.numeric(as.character(X))) |&gt; 
  select(year, y, x)

modelo &lt;- lm(log(y) ~ log(x), data = data)
data &lt;- data |&gt; mutate(u = resid(modelo), u_e = u/sd(u))

ggplot(data) +
  geom_line(aes(x=year, y=u), color = "blue") +
  geom_line(aes(x=year, y=u_e/46), color = "red") + # 46 = max(data$u_e)/max(data$u)
  geom_hline(yintercept = 0) +
  scale_y_continuous(name = "u", sec.axis = sec_axis(~.*46, name = "u_e"))
```

&lt;img src="Autocorrelacion_files/figure-html/unnamed-chunk-2-1.png" width="46%" style="display: block; margin: auto;" /&gt;

Observamos que tanto `\(\widehat{u}_t\)` como `\(\widehat{u}_t\)` estandarizados presentan un patrón, lo que indica que tal vez las `\(\widehat{u}_t\)` no sean aleatorias

---
# &lt;span style="font-size:80%"&gt;Detección de la autocorrelación&lt;/span&gt;
Para ver esto en forma diferente, podemos graficar `\(\widehat{u}_t\)` respecto de `\(\widehat{u}_{t-1}\)`, es decir, el residuo en el tiempo `\(t\)` frente a su valor en el tiempo `\((t-1)\)`, una clase de prueba empírica del esquema AR(1)


```r
data &lt;- data |&gt; mutate(u_lag1 = lag(u, 1))

ggplot(data, aes(x=u_lag1, y=u)) +
  geom_point(color = "blue", size = 3) +
  geom_hline(yintercept = 0) + geom_vline(xintercept = 0) +
  geom_smooth(method = "lm", se = FALSE, formula= y~x, color="red")
```

&lt;img src="Autocorrelacion_files/figure-html/unnamed-chunk-3-1.png" width="50%" style="display: block; margin: auto;" /&gt;

Como muestra esta figura, la mayoría de los residuos están agrupados en el segundo y el cuarto cuadrantes, lo cual indica una &lt;font color = "blue"&gt;correlación positiva fuerte en los residuos&lt;/font&gt;

---
# &lt;span style="font-size:80%"&gt;Detección de la autocorrelación&lt;/span&gt;

&lt;font color = "blue"&gt;2. Prueba `\(d\)` de Durbin-Watson

&lt;font color = "black"&gt;
- La prueba más conocida para detectar correlación serial es la de los estadísticos Durbin y Watson

- Se le conoce como &lt;font color = "blue"&gt;estadístico `\(d\)` de Durbin-Watson&lt;/font&gt;, que se define como:

`$$d = \frac{\sum\limits_{t=2}^{T} (\widehat{u}_{t}-\widehat{u}_{t-1})^2}{\sum\limits_{t=1}^{T} \widehat{u}_{t}^2}$$`

- Aunque el estadístico `\(d\)` se utiliza ahora en forma rutinaria, &lt;font color = "blue"&gt;es importante observar los supuestos en los cuales se basa&lt;/font&gt;:
&lt;p style="margin-bottom: -1em"&gt;	
	- El modelo de regresión incluye el término del intercepto
	- Las perturbaciones `\(u_t\)` se generan mediante el esquema autorregresivo de primer orden: `\(u_t = \rho u_{t - 1} + \epsilon_t\)`. Por tanto, no se pueden utilizar para detectar esquemas autorregresivos de orden superior
	- Se supone que el término de error `\(u_t\)` está normalmente distribuido `\(\Longrightarrow\)` `\(d\longrightarrow 2\)`
	- El modelo de regresión no incluye valor(es) rezagado(s) de la variable dependiente como una variable explicativa
	- No hay observaciones faltantes en los datos

---
# &lt;span style="font-size:80%"&gt;Detección de la autocorrelación&lt;/span&gt;

- El muestreo exacto o la distribución de probabilidad del estadístico `\(d\)` es difícil de derivar porque, como demostraron Durbin y Watson, tiene una dependencia compleja de los valores presentes de `\(X\)` en una muestra dada

- Por consiguiente, a diferencia de las pruebas `\(t\)`, `\(F\)` o `\(\chi^2\)`, no hay un valor crítico único que lleve al rechazo o al no rechazo de la hipótesis nula de que no hay correlación serial de primer orden en las perturbaciones `\(u_t\)`

- Sin embargo, Durbin y Watson lograron encontrar un límite inferior `\(d_L\)` y un límite superior `\(d_U\)` tales que si el valor `\(d\)` calculado cae por fuera de estos valores críticos, puede tomarse una decisión respecto de la presencia de correlación serial positiva o negativa

- Además, estos límites sólo dependen del número de observaciones `\(n\)` y del número de variables explicativas, y no de los valores que adquieren estas variables explicativas

- Para determinar la presencia o ausencia de autocorrelación del tipo AR(1) se siguen las siguientes reglas:

	- Ausencia de autocorrelación: `\(d=2\)`
	- Autocorrelación positiva: `\(0\leq d\leq 2\)`
	- Autocorrelación negativa: `\(2 &lt; d \leq 4\)`

---
# &lt;span style="font-size:80%"&gt;Detección de la autocorrelación&lt;/span&gt;

Como se mencionó, `\(d\)` no tiene una distribución exacta y, por tanto, se trabaja con umbrales críticos. La distribución se tabula por `\(d_L\)` y `\(d_U\)`:

- `\(0\leq d &lt; d_L\)`: &lt;font color = "blue"&gt;autocorrelación lineal positiva&lt;/font&gt;
- `\(d_L\leq d &lt; d_U\)`: &lt;font color = "blue"&gt;resultado incierto - test no concluyente&lt;/font&gt;
- `\(d_U\leq d &lt; 4-d_U\)`: &lt;font color = "blue"&gt;no hay autocorrelación&lt;/font&gt;
- `\(4-d_U\leq d &lt; 4-d_L\)`: &lt;font color = "blue"&gt;resultado incierto - test no concluyente&lt;/font&gt;
- `\(4-d_L\leq d &lt; 4\)`: &lt;font color = "blue"&gt;autocorrelación lineal negativa&lt;/font&gt;

Gráficamente:

&lt;img src="d.png" width="55%" style="display: block; margin: auto;" /&gt;

---
# &lt;span style="font-size:80%"&gt;Detección de la autocorrelación&lt;/span&gt;
	
&lt;font color = "blue"&gt;3. Test basados en el correlograma&lt;/font&gt;
&lt;p style="margin-bottom: -1em"&gt;
&lt;font size = "3"&gt;
	
El correlograma de una serie temporal se basa en dos funciones:
&lt;p style="margin-bottom: -1em"&gt;
- la función de autocorrelación simple (*Autocorrelation - AC*)
- la función de autocorrelación parcial (*Partial autocorrelation - PAC*)

&lt;font color = "blue"&gt;Autocorrelation - AC&lt;/font&gt;&lt;br&gt;
Se construye con base en las correlaciones simples de la serie con sus rezagos

`\(\widehat{\rho}_1\)`: primer coeficiente de autocorrelación, es la correlación simple de la serie en `\(t\)` y en `\(t-1\)`

`$$\rho_1 = Cov(u_t , u_{t-1}) = \frac{Cov(u_t , u_{t-1})}{\sigma_{u_{t}}\sigma_{u_{t-1}}} = \frac{Cov(u_t , u_{t-1})}{Var(u_t)}$$`

&lt;p style="margin-bottom: -1em"&gt;
Empíricamente
`$$\widehat{\rho}_1 = \frac{\sum\limits_{t=2}^{T} \widehat{u}_t \widehat{u}_{t-1}}{\sum\limits_{t=2}^{T} \widehat{u}_{t}^2}$$`
&lt;p style="margin-bottom: -1em"&gt;
Y así en general el `\(\rho_s = \frac{Cov(u_t , u_{t-s})}{Var(u_t)}\)` y en términos empíricos:

`$$\widehat{\rho}_s = \frac{\sum\limits_{t=2}^{T} \widehat{u}_t \widehat{u}_{t-s}}{\sum\limits_{t=2}^{T} \widehat{u}_{t}^2}$$`

---
# &lt;span style="font-size:80%"&gt;Detección de la autocorrelación&lt;/span&gt;

&lt;font color = "blue"&gt;Partial autocorrelation - PAC&lt;/font&gt;&lt;br&gt;
Se construye con base en los coeficientes de correlación parcial entre las series y sus rezagos. La forma más sencilla de calcularlos son a partir de las ecuaciones de Yule y Walker

Se estiman las siguientes regresiones:

`$$\widehat{u}_t = \widehat{\phi}_{11}\widehat{u}_{t-1} + residuo$$`
`\(\widehat{\phi}_{11}\)`: primer coeficiente de autocorrelación parcial (coincide con `\(\widehat{\rho}_1\)`)

`$$\widehat{u}_t = \widehat{\phi}_{12}\widehat{u}_{t-1} + \widehat{\phi}_{22}\widehat{u}_{t-2} + residuo$$`
`\(\widehat{\phi}_{22}\)`: segundo coeficiente de autocorrelación parcial

En general, `\(\widehat{\phi}_{ss}\)` en la regresión de `\(\widehat{u}_{t} = f(\widehat{u}_{t-1},\widehat{u}_{t-2},...,\widehat{u}_{t-s})\)` es el enésimo coeficiente de correlación parcial
&lt;p style="margin-bottom: -1em"&gt;
Para construir el correlograma se requiere las respectivas varianzas:

`$$Var(\widehat{\rho}_s) \cong \frac{1}{T}(1+2(\widehat{\rho}_{1}^2 + \widehat{\rho}_{2}^2 +...+\widehat{\rho}_{s-1}^2))$$`
`$$Var(\widehat{\phi}_{ss}) \cong \frac{1}{T}$$`

En general, `\(\frac{\widehat{\rho}_s}{\sqrt{Var(\widehat{\rho}_s)}}\)` y `\(\frac{\widehat{\phi}_{ss}}{\sqrt{Var(\widehat{\phi}_{ss})}}\)` `\(\longrightarrow\)` `\(N(0,1)\)`

---
# &lt;span style="font-size:80%"&gt;Detección de la autocorrelación&lt;/span&gt;

La AC y PAC no solo se usan para diagnosticar autocorrelación, sino también para identificar el proceso generador de datos de la serie

Si el proceso fuese un AR(1): `\(u_t = \phi u_{t-1} + \epsilon_t\)`

|AC    |||  PAC|
|:----:|||:-----:|
| `\(\widehat{\rho}_1 =\frac{\phi \sigma_{u}^2}{\sigma_{u}^2}=\phi\)` ||| `\(\phi_{11} = \phi\)`|
| `\(\widehat{\rho}_2 = \phi^2\)`                                     ||| `\(\phi_{12} = 0\)`|
| `\(\vdots\)`                                                        ||| `\(\vdots\)`|
| `\(\widehat{\rho}_s = \phi^s\)`                                     ||| `\(\phi_{1s} = 0\)`|  

Mientras la AC disminuye lentamente, la PAC se corta abruptamente

---
# &lt;span style="font-size:80%"&gt;Detección de la autocorrelación&lt;/span&gt;

Simulamos un proceso AR(1)

```r
ar1 &lt;- arima.sim(list(ar=.8), n=500)
```


.small-code[
.pull-left-50[

```r
acf(ar1, 26, xlim=c(1,26), ylim=c(-.1,.9), main = "", ylab = "", xlab = "", xaxt="none", cex=1.5)
axis(1, 1:26)
mtext(side=1, line=3, "Lag",cex=1.5)
mtext(side=2, line=3, "Autocorrelation (AC)",cex=1.5)
```

&lt;img src="Autocorrelacion_files/figure-html/unnamed-chunk-6-1.png" width="100%" style="display: block; margin: auto;" /&gt;
]

.pull-right-50[

```r
pacf(ar1, 26, ylim=c(-.1,.9), main = "", ylab = "", xlab = "", xaxt="none")
axis(1, 1:26)
mtext(side=1, line=3, "Lag",cex=1.5)
mtext(side=2, line=3, "Partial autocorrelation (PAC)",cex=1.5)
```

&lt;img src="Autocorrelacion_files/figure-html/unnamed-chunk-7-1.png" width="100%" style="display: block; margin: auto;" /&gt;
]
]

---
# &lt;span style="font-size:80%"&gt;Detección de la autocorrelación&lt;/span&gt;

Con un proceso MA(1) sucede todo lo contrario: `\(u_t = \theta\epsilon_{t-1} + \epsilon_{t}\)`

Simulamos un proceso MA(1)

```r
ma1 &lt;- arima.sim(list(ma=.7), n=500)
```

&lt;p style="margin-bottom: -1em"&gt;
.small-code[
.pull-left-50[

```r
acf(ma1, 26, xlim=c(1,26), ylim=c(-.3,.5), main = "", ylab = "", xlab = "", xaxt="none")
axis(1, 1:26)
mtext(side=1, line=3, "Lag",cex=1.5)
mtext(side=2, line=3, "Autocorrelation (AC)",cex=1.5)
```

&lt;img src="Autocorrelacion_files/figure-html/unnamed-chunk-9-1.png" width="100%" style="display: block; margin: auto;" /&gt;
]

.pull-right-50[

```r
pacf(ma1, 26, ylim=c(-.3,.5), main = "", ylab = "", xlab = "", xaxt="none")
axis(1, 1:26)
mtext(side=1, line=3, "Lag",cex=1.5)
mtext(side=2, line=3, "Partial autocorrelation (PAC)",cex=1.5)
```

&lt;img src="Autocorrelacion_files/figure-html/unnamed-chunk-10-1.png" width="100%" style="display: block; margin: auto;" /&gt;
]
]

En la modelación ARMA, el correlograma es fundamental para identificar p y q

---
# &lt;span style="font-size:80%"&gt;Detección de la autocorrelación&lt;/span&gt;

&lt;font color = "blue"&gt;4. La prueba de multiplicadores de Lagrange (LM) o de Breusch-Godfrey (BF)&lt;/font&gt;

Para evitar algunos inconvenientes de la prueba `\(d\)` de Durbin-Watson, se propuso una prueba para la autocorrelación que es general porque permite:
- regresoras no estocásticas, como los valores rezagadas de la regresada
- esquemas autorregresivos de orden mayor, como el AR(1), AR(2), etc
- MA simples o de orden superior

El test funciona de la siguiente forma: asuma el siguiente modelo con una estructura AR(p) en `\(u_t\)`

`$$Y_t = \beta_1 + \beta_2 X_t + u_t$$`
`$$u_t=\rho_1 u_{t-1} + \rho_2 u_{t-2} +...+ \rho_p u_{t-p} + \epsilon_t$$`
La hipótesis nula `\(H_0\)` por demostrar es

`$$H_0 = \rho_1 = \rho_2 = ... = \rho_p =0$$`
Es decir, no existe correlación serial de ningún orden

---
# &lt;span style="font-size:80%"&gt;Detección de la autocorrelación&lt;/span&gt;

La prueba LM implica los siguientes pasos:

1. Estime el modelo por MCO y obtenga `\(\widehat{u}_t\)`
2. Haga la regresión `\(\widehat{u}_t\)` sobre las `\(X_t\)` y `\(\widehat{u}_{t-1}\)`, `\(\widehat{u}_{t-2}\)`, ... `\(\widehat{u}_{t-p}\)`, y obtenga `\(R^2\)` de esta regresión auxiliar
3. Si el tamaño de la muestra es grande, Breusch y Godfrey demostraron que

`$$LM=nR^2 \sim \chi_{p}^2$$`
Se rechaza `\(H_0\)` si `\(LM&gt;\chi_{tabla}^2\)` o si pvalue&lt; 1, 5, 10%

---
# &lt;span style="font-size:80%"&gt;Detección de la autocorrelación&lt;/span&gt;

&lt;font color = "blue"&gt;5. Test de Ljung-Box&lt;/font&gt;

Diseñados para procesos AR(p)

`$$u_t=\rho_1 u_{t-1} + \rho_2 u_{t-2} +...+ \rho_p u_{t-p} + \epsilon_t$$`
La hipótesis nula `\(H_0\)` es

`$$H_0 = \rho_1 = \rho_2 = ... = \rho_p =0$$`
Es decir, no existe correlación serial de ningún orden

El estadístico de prueba es

`$$Q = T(T+2)\left[ \frac{\widehat{\rho}_{1}^2}{T-1} + \frac{\widehat{\rho}_{2}^2}{T-2} + ... + \frac{\widehat{\rho}_{p}^2}{T-p} \right]\longrightarrow \chi_{p}^2$$`
Es un test de validez asintótica y su regla de decisión es rechazar `\(H_0\)` si `\(Q&gt;\chi_{tabla}^2\)` o si pvalue&lt; 1, 5, 10%

---
name: solucion
# &lt;span style="font-size:80%"&gt;Solución a la autocorrelación: el estimador MCG&lt;/span&gt;

La idea es transformar el modelo (los datos y la perturbación aleatoria) de tal forma que la perturbación aleatoria del modelo transformado, tenga esfericidad y se puedan aplicar MCO a los datos del modelo transformado

`$$\textbf{Y} = \textbf{XB} + \textbf{u}$$`
`$$E(\textbf{u})=\textbf{0}$$`
`$$E(\textbf{X}'\textbf{u})=\textbf{0}$$`
`$$Cov(\textbf{u})=E(\textbf{u}\textbf{u}')=\sigma_{u}^2\boldsymbol\Omega$$`

Siendo `\(\boldsymbol\Omega\)` una matriz definida positiva, pues se trata de varianzas

Las matrices definidas positivas pueden descomponerse como:

`$$\boldsymbol\Omega = \textbf{PP}'$$`

Siendo **P** una matriz no singular `\((\textbf{P}^{-1}\)` existe). En el mundo matricial, dadas las propiedades de la inversión de matrices, se da que:

`$$\boldsymbol\Omega^{-1} = (\textbf{PP}')^{-1} = \textbf{P}'^{-1}\textbf{P}^{-1} = \textbf{P}^{-1'}\textbf{P}^{-1}$$`

La propuesta de los MCG es premultiplicar todo el modelo por `\(\textbf{P}^{-1}\)`

`$$\textbf{P}^{-1}\textbf{Y} = \textbf{P}^{-1}\textbf{XB} + \textbf{P}^{-1}\textbf{u}$$`
`$$\textbf{Y}^* = \textbf{X}^*\textbf{B} + \textbf{u}^*$$`
---
# &lt;span style="font-size:80%"&gt;Solución a la autocorrelación: el estimador MCG&lt;/span&gt;
&lt;font size = "2"&gt;
Si la perturbación `\(\textbf{u}^*\)` es esférica se puede aplicar MCO al modelo con base en `\(\textbf{Y}^*\)` y `\(\textbf{X}^*\)`. Hay que ver los supuestos para `\(\textbf{u}^*\)`

`$$E(\textbf{u}^*) = E(\textbf{P}^{-1}\textbf{u}) = \textbf{P}^{-1}E(\textbf{u})=\textbf{0}$$`
$$
`\begin{aligned}
Cov(\textbf{u}^*)     &amp; = E((\textbf{u}^* - E(\textbf{u}^*))((\textbf{u}^* - E(\textbf{u}^*))')= E(\textbf{u}^*\textbf{u}^*{'})\\
                      &amp; = E(\textbf{P}^{-1}\textbf{u}\textbf{u}{'}\textbf{P}^{-1}{'}) = \textbf{P}^{-1}E(\textbf{u}\textbf{u}{'})\textbf{P}^{-1}{'}\\
                      &amp; = \sigma_{u}^2 \textbf{P}^{-1}\boldsymbol\Omega\textbf{P}^{-1}{'}\\
                      &amp; = \sigma_{u}^2 \textbf{P}^{-1}\textbf{P}\textbf{P}{'}\textbf{P}^{-1}{'}\\
                      &amp; =\sigma_{u}^2\textbf{I}
\end{aligned}`
$$

Por lo tanto, en le modelo `\(\textbf{Y}^* = \textbf{X}^*\textbf{B} + \textbf{u}^*\)` se cumple la hipótesis de perturbaciones esféricas y se puede aplicar MCO al modelo transformado, dando como resultado `\(\widehat{\textbf{B}}_{MCG}\)`

$$
`\begin{aligned}
\widehat{\textbf{B}}_{MCG} &amp; = (\textbf{X}^*{'}\textbf{X}^*)^{-1}\textbf{X}^*{'}\textbf{Y}^* \\
                           &amp; = ((\textbf{P}^{-1}\textbf{X}){'}(\textbf{P}^{-1}\textbf{X}))^{-1}(\textbf{P}^{-1}\textbf{X}){'}\textbf{P}^{-1}\textbf{Y}\\
                           &amp; = (\textbf{X}{'}\textbf{P}^{-1}{'}\textbf{P}^{-1}\textbf{X})^{-1}\textbf{X}{'}\textbf{P}^{-1}{'}\textbf{P}^{-1}\textbf{Y}\\
                           &amp; = (\textbf{X}'\boldsymbol\Omega^{-1}\textbf{X})^{-1}\textbf{X}'\boldsymbol\Omega^{-1}\textbf{Y}
\end{aligned}`
$$

`\(\widehat{\textbf{B}}_{MCO}\)` son un caso particular cuando `\(\boldsymbol\Omega=\textbf{I}\)`

Es inmediato plantear que en el modelo transformado

`$$Cov(\widehat{\textbf{B}}_{MCG}) = \sigma_{u}^2(\textbf{X}'\boldsymbol\Omega\textbf{X})^{-1}$$`

Para obtener `\(\boldsymbol\Omega\)` hay que modelar el tipo de situación específica que se quiere resolver, estos es si la autocorrelación es del tipo AR(1), MA(1), etc  

---
# &lt;span style="font-size:80%"&gt;Solución a la autocorrelación: el estimador MCG&lt;/span&gt;

Descartado un origen de la autocorrelación en la incorrecta especificación del modelo se debe encontrar un proceso geneador de datos (PGD) que de cuenta de la autocorrelación. Suponiendo que dicho proceso sea un AR(1), es decir:

`$$\textbf{Y} = \textbf{XB} + \textbf{u}$$`
`$$u_t = \rho u_{t-1} + \epsilon_t$$`
con `\(\epsilon_t\)` ruido blanco 


Es posible demostrar que

`$$\textbf{P}^{-1} = \left[ \begin{array}{cccccc}
\sqrt{1-\rho^2}   &amp; 0      &amp; 0     &amp;. &amp; .    &amp; 0  \\
-\rho             &amp; 1      &amp; 0     &amp;. &amp; .    &amp; 0   \\
0                 &amp; -\rho  &amp; 1     &amp;. &amp; .    &amp; -\rho\\
.            &amp; . &amp; .&amp; .&amp; .    &amp; .\\
.            &amp; . &amp; .&amp; .&amp; 1    &amp; 0\\
0                 &amp; 0      &amp; 0     &amp; .&amp;-\rho &amp; 1  \\ \end{array} \right]_{T\text{x}T}$$`
Recordando que la solución MCG es transformar el modelo y obtener

`$$\textbf{P}^{-1}\textbf{Y} = \textbf{P}^{-1}\textbf{XB} + \textbf{P}^{-1}\textbf{u}$$`

---
# &lt;span style="font-size:80%"&gt;Solución a la autocorrelación: el estimador MCG&lt;/span&gt;

&lt;font size = "3"&gt;
En matrices se tiene

`$$\textbf{P}^{-1}\textbf{Y} = \left[ \begin{array}{c}
\sqrt{1-\rho^2}Y_{1} \\
Y_{2} - \rho Y_{1} \\
Y_{3} - \rho Y_{2} \\
\vdots \\
Y_{t} - \rho Y_{t-1} \\ \end{array} \right] \   \ \textbf{P}^{-1}\textbf{X} = \left[ \begin{array}{cccc}
\sqrt{1-\rho^2}  &amp; \sqrt{1-\rho^2}X_{21} &amp; \ldots &amp;  \sqrt{1-\rho^2}X_{k1} \\
1-\rho           &amp; X_{22} - \rho X_{21}  &amp; \ldots &amp;  X_{k2} - \rho X_{k1} \\
1-\rho           &amp; X_{23} - \rho X_{22}  &amp; \ldots &amp;  X_{k3} - \rho X_{k2} \\
\vdots \\
1-\rho           &amp; X_{2T} - \rho X_{2T-1}  &amp; \ldots &amp;  X_{kT} - \rho X_{kT-1} \\ \end{array} \right]$$`

Se conoce como primeras diferencias &lt;font color = "blue"&gt;GENERALIZADAS&lt;/font&gt;, cada observación menos `\(\rho\)`  veces la anterior

En estricto rigor el MCG lleva a una regresión:
- sin intercepto
- modificando la primera observación por `\(\sqrt{1-\rho^2}\)`
- el resto de observaciones como primera diferencia generalizada

En el modelo transformado la primera observación viene generada por:

`$$\sqrt{1-\rho^2} Y_1 = \sqrt{1-\rho^2} \beta_1 + \sqrt{1-\rho^2} \beta_2 X_{12} + ... + \sqrt{1-\rho^2} \beta_k X_{k1} + \epsilon_1$$`

El resto de las observaciones `\(t=2,3,...,T\)` viene dado por:

`$$Y_t - \rho Y_{t-1} = \beta_1(1-\rho) + \beta_2(X_{2t}-\rho X_{2t-1}) + ... + \beta_k(X_{kt}-\rho X_{kt-1}) + \epsilon_t$$`

---
# &lt;span style="font-size:80%"&gt;Solución a la autocorrelación: el estimador MCG&lt;/span&gt;

En el anterior modelo transformado sólo falta encontrar un valor para `\(\rho\)`. Existen varias formas de hacerlo

- De manera directa a partir del Durbin-Watson

`$$d = 2(1-\widehat{\rho}) \Longrightarrow \widehat{\rho} = 1 - \frac{d}{2}$$`

- Estimando `\(\rho\)` a partir del residuo: &lt;br&gt; 
se estima `\(Y_t = X_{t}'\widehat{\beta} + \widehat{u}_t\)` &lt;br&gt;
se estima `\(\widehat{u}_t = \widehat{\rho}\widehat{u}_{t-1} + \epsilon\)` &lt;br&gt;
`\(\widehat{\rho}\)`: primero coeficiente de autocorrelación
	
- Método de Durbin&lt;br&gt;
La idea viene de estimar el modelo en primeras diferencias generalizadas y despejar `\(\widehat{\rho}\)`.	Se estima un modelo en el cual `\(Y_t = f(Y_{t-1}, X_{2t},X_{2t-1},...,X_{kt},X_{kt-1})\)`, y la propuesta de Durbin es tomar el coeficiente estimado de `\(Y_{t-1}\)` como `\(\widehat{\rho}\)`
	
- Malla de Hildrelh-Lu &lt;br&gt;
Es un procedimiento de búsqueda típico de los métodos de análisis numérico. La idea es buscar numéricamente el `\(\widehat{\rho}\)` que minimiza la SCR del modelo transformado

---
# &lt;span style="font-size:80%"&gt;Solución a la autocorrelación: el estimador MCG&lt;/span&gt;

- Procedimiento iterativo de Cochranne-Orcutt&lt;br&gt;
En estricto rigor es una solución de MV al  problema de Autocorrelación. También busca minimizar la SCR pero con una estrategia diferente
	
 - Se estima el modelo inicial `\(Y_t = X_{t}'\widehat{\beta} + \widehat{u}_t\)`
 - Se obtiene un estimativo de `\(\widehat{\rho}\)` (a partir del `\(d\)` o del residuo)
 - Se transformo el modelo (normalmente excluyendo la primera observación) y se vuelve a obtener  `\(\widehat{\widehat{\beta}}\)` y unos nuevos residuos
 - Se repite el proceso hasta la convergencia
`$$\widehat{\beta}\longrightarrow \widehat{u}_t \longrightarrow \widehat{\rho} \longrightarrow \widehat{\widehat{\beta}} \longrightarrow \widehat{\widehat{u}} \longrightarrow \widehat{\widehat{\rho}} \longrightarrow ...$$`
Note que en vista de que se utiliza `\(\widehat{\rho}\)` en vez de la verdadera `\(\rho\)`, todos estos métodos de estimación se conocen en la bibliografía como métodos MCG factibles (MCGF) o MCG estimados (MCGE).

---
# &lt;span style="font-size:80%"&gt;Solución a la autocorrelación: el estimador MCG&lt;/span&gt;

Existen tres procedimientos muy utilizados en el ejercicio empírico para corregir autocorrelación (procedimientos disponibles en softwares como R o Stata):

- el método de Prais–Winsten: procedimiento iterativo, asume estructura AR(1), preserva la 1a obs 

- el método Cochrane–Orcutt: procedimiento iterativo, asume estructura AR(1), pierde la 1a obs

- el método Newey-West (corrige heterocedasticidad y autocorrelación)

---
name: r
# &lt;span style="font-size:80%"&gt;Ejercicio aplicado en R: relación entre salarios y productividad&lt;/span&gt;

En este ejemplo vamos analizar la relación entre salarios y productividad en el sector de negocios de Estados Unidos entre 1960 y 2005. Se tienen datos sobre índices de remuneración real por hora (Y) y producción por hora (X), la base de los índices es 1992=100

- [Código en R](https://gusgarciacruz.github.io/EconometriaII/Autocorrelacion/Autocorrelacion.R)


```r
library(tidyverse); library(Hmisc); library(forecast); library(lmtest); library(prais); library(orcutt); library(sandwich); library(gujarati)

data("Table12_4")
data &lt;- Table12_4 |&gt; mutate(year = as.numeric(as.character(Year)),
                            y = as.numeric(as.character(Y)), x = as.numeric(as.character(X))) |&gt; select(year, y, x)
```

Graficamos salarios contra productividad


```r
ggplot(data, aes(x=x, y=y)) +
  geom_point(color = "blue", size = 4) +
  labs(x="Productividad", y="Salarios") +
  geom_smooth(method = "lm", se = FALSE, formula= y~x, color="red")
```

&lt;img src="Autocorrelacion_files/figure-html/unnamed-chunk-12-1.png" width="35%" style="display: block; margin: auto;" /&gt;

---
# &lt;span style="font-size:80%"&gt;Ejercicio aplicado en R: relación entre salarios y productividad&lt;/span&gt;
&lt;font size = "3"&gt;
.small-code[
.pull-left-50[
Estimamos un modelo de regresión en logs

```r
modelo &lt;- lm(log(y) ~ log(x), data=data)
summary(modelo)
```

```

Call:
lm(formula = log(y) ~ log(x), data = data)

Residuals:
      Min        1Q    Median        3Q       Max 
-0.041164 -0.017041  0.001037  0.018077  0.038719 

Coefficients:
            Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept)  1.60668    0.05471   29.37   &lt;2e-16 ***
log(x)       0.65222    0.01235   52.80   &lt;2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 0.02208 on 44 degrees of freedom
Multiple R-squared:  0.9845,	Adjusted R-squared:  0.9841 
F-statistic:  2788 on 1 and 44 DF,  p-value: &lt; 2.2e-16
```
]

.pull-right-50[
&lt;font color = "blue"&gt;Detección de la autocorrelación&lt;/font&gt;&lt;br&gt;
Graficando los residuales

```r
data &lt;- data |&gt; mutate(u = modelo$residuals, u_e = rstandard(modelo))

ggplot(data, aes(x=year, y=u)) +
  geom_line(color = "blue") + labs(x="Años", y="Residuales")
```

&lt;img src="Autocorrelacion_files/figure-html/unnamed-chunk-14-1.png" width="50%" style="display: block; margin: auto;" /&gt;

```r
ggplot(data, aes(x=year, y=u_e)) +
  geom_line(color = "blue") +  labs(x="Años", y="Residuales estandarizados")
```

&lt;img src="Autocorrelacion_files/figure-html/unnamed-chunk-14-2.png" width="50%" style="display: block; margin: auto;" /&gt;
Observamos que tanto u como u_e presentan un patrón, lo que indica que tal vez los residuales no sean aleatorios
]
]


---
# &lt;span style="font-size:80%"&gt;Ejercicio aplicado en R: relación entre salarios y productividad&lt;/span&gt;

Graficando `\(u_t\)` contra `\(u_{t-1}\)`

```r
data &lt;- data |&gt; mutate(u_lag1 = lag(u, 1))

ggplot(data, aes(x=u_lag1, y=u)) +
  geom_point(color = "blue", size = 3) +
  geom_hline(yintercept = 0) + geom_vline(xintercept = 0) +
  geom_smooth(method = "lm", se = FALSE, formula= y~x, color="red")
```

&lt;img src="Autocorrelacion_files/figure-html/unnamed-chunk-15-1.png" width="50%" style="display: block; margin: auto;" /&gt;


---
# &lt;span style="font-size:80%"&gt;Ejercicio aplicado en R: relación entre salarios y productividad&lt;/span&gt;

Test de Durbin-Watson

```r
dwtest(modelo)
```

```

	Durbin-Watson test

data:  modelo
DW = 0.21756, p-value &lt; 2.2e-16
alternative hypothesis: true autocorrelation is greater than 0
```

Test LM o de Breusch-Godfrey (BF)

```r
bgtest(modelo, order=1)
```

```

	Breusch-Godfrey test for serial correlation of order up to 1

data:  modelo
LM test = 34.02, df = 1, p-value = 5.456e-09
```

```r
coeftest(bgtest(modelo, order=1))
```

```

z test of coefficients:

               Estimate Std. Error z value Pr(&gt;|z|)    
(Intercept)   0.0062584  0.0282482  0.2216   0.8247    
log(x)       -0.0015019  0.0063783 -0.2355   0.8138    
lag(resid)_1  0.8686522  0.0786108 11.0500   &lt;2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
```

---
# &lt;span style="font-size:80%"&gt;Ejercicio aplicado en R: relación entre salarios y productividad&lt;/span&gt;

Test basados en el correlograma

.small-code[
.pull-left-50[

```r
ggAcf(data$u,main="ACF de los residuales")
```

&lt;img src="Autocorrelacion_files/figure-html/unnamed-chunk-18-1.png" width="100%" style="display: block; margin: auto;" /&gt;
]

.pull-right-50[

```r
ggPacf(data$u,main="PAC de los residuales", ylab="PAC")
```

&lt;img src="Autocorrelacion_files/figure-html/unnamed-chunk-19-1.png" width="100%" style="display: block; margin: auto;" /&gt;
]
]

Se detecta un problema de autocorrelación en los residuales y es del tipo AR(1)

---
# &lt;span style="font-size:80%"&gt;Ejercicio aplicado en R: relación entre salarios y productividad&lt;/span&gt;

Test de Ljung-Box

```r
Box.test(data$u, lag = 1, type = "Ljung-Box")
```

```

	Box-Ljung test

data:  data$u
X-squared = 35.566, df = 1, p-value = 2.465e-09
```


---
# &lt;span style="font-size:80%"&gt;Ejercicio aplicado en R: relación entre salarios y productividad&lt;/span&gt;

&lt;font color = "blue"&gt;Corrección de la autocorrelación&lt;/font&gt;&lt;br&gt;

.small-code[
.pull-left-50[
El método de Prais-Winsten: corrige AR(1)

```r
pw &lt;- prais_winsten(log(y)~log(x), data = data, index = data$year)
```

```
Iteration 0: rho = 0
Iteration 1: rho = 0.8679
Iteration 2: rho = 0.8912
Iteration 3: rho = 0.8953
Iteration 4: rho = 0.8962
Iteration 5: rho = 0.8964
Iteration 6: rho = 0.8964
Iteration 7: rho = 0.8964
Iteration 8: rho = 0.8964
Iteration 9: rho = 0.8964
```

```r
summary(pw)
```

```

Call:
prais_winsten(formula = log(y) ~ log(x), data = data, index = data$year)

Residuals:
     Min       1Q   Median       3Q      Max 
-0.03546 -0.01079  0.00693  0.02630  0.04666 

AR(1) coefficient rho after 9 iterations: 0.8964

Coefficients:
            Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept)  1.56421    0.13458   11.62  5.3e-15 ***
log(x)       0.66009    0.03035   21.75  &lt; 2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 0.01014 on 44 degrees of freedom
Multiple R-squared:  0.9974,	Adjusted R-squared:  0.9974 
F-statistic: 1.721e+04 on 1 and 44 DF,  p-value: &lt; 2.2e-16

Durbin-Watson statistic (original): 0.2176 
Durbin-Watson statistic (transformed):  1.67
```
]

.pull-right-50[
 El método Cochrane-Orcutt: corrige AR(1)

```r
coch &lt;- cochrane.orcutt(modelo)
summary(coch)
```

```
Call:
lm(formula = log(y) ~ log(x), data = data)

            Estimate Std. Error t value  Pr(&gt;|t|)    
(Intercept) 1.955389   0.192416  10.162 5.283e-13 ***
log(x)      0.576819   0.041914  13.762 &lt; 2.2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 0.0096 on 43 degrees of freedom
Multiple R-squared:  0.815 ,  Adjusted R-squared:  0.8107
F-statistic: 189.4 on 1 and 43 DF,  p-value: &lt; 2.349e-17

Durbin-Watson statistic 
(original):    0.21756 , p-value: 5.098e-19
(transformed): 1.70388 , p-value: 1.253e-01
```
El método Newey-West: corrige con orden de rezago más alto

```r
coeftest(modelo,vcov=NeweyWest(modelo,lag=2,verbose=T))
```

```

Lag truncation parameter chosen: 2 
```

```

t test of coefficients:

            Estimate Std. Error t value  Pr(&gt;|t|)    
(Intercept) 1.606680   0.187208  8.5823 5.975e-11 ***
log(x)      0.652216   0.043447 15.0118 &lt; 2.2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
```
]
]

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
